---
title: C++虚函数
categories: C++
date: 2018-03-19 00:00:00
tags:
- 虚函数
- 虚指针
- 虚表
---

## 1.关于多态

  在C++中，多态有两种形式，一个叫静态多态，一个叫动态多态。多态，就是一个接口的不同表现方式，静态多态，在程序编译的时候，就已经表现出多种形式，如函数重载。动态多态，就是在程序运行的时候，根据对象的类型，调用各自对象的方法。

## 2.虚函数

  C++实现多态的主要方式为 **继承+虚指针**。虚函数的作用：当把一个函数写为虚函数的时候，就意味着，这个函数是要被子类重写的。这样的话，通过父类指针指向子类对象的时候，通过父类指针调用方法的时候，就可以调用到子类的方法。

```C++
#include <iostream>
using namespace std;
class Base
{
public:
    void print()
    {
        cout<<"It is father func"<<endl;
    }
};
class Child:public Base
{
  public:
    void print()
    {
        cout<<"It is child function"<<endl;
    }
};
int main()
{
    Base  *s=new Child();
    s->print();//输出It is father func
    return 0;
}

```

当把print方法写为虚函数的时候

```C++
#include <iostream>
using namespace std;
class Base
{
public:
    virtual void print()
    {
        cout<<"It is father func"<<endl;
    }
};
class Child:public Base
{
  public:
    void print()
    {
        cout<<"It is child function"<<endl;
    }
};
int main()
{
    Base  *s=new Child();
    s->print();//输出It is child function
    return 0;
}
```

再提一句，父类指针可以指向子类的对象，而子类指针不可以指向父类对象。其实，也很好理解，就如同父类是个animal，而子类是个bird，bird is a animal，而animal 不全是bird，那样，就访问了不该访问的东西。

## 3.虚指针和虚表

每当一个类包含一个虚函数的时候，编译时就会给此类添加一个虚表，给这个类的对象增加一个虚指针，虚指针指向虚表，虚表里面存放着虚函数的地址，这样，当不同的对象调用其方法时，由虚指针决定调用哪个函数。

* 1.一个空类，理论来说，其大小应该是0，但C++规定，类大小不能为0，所以，就是1。

![](http://ww1.sinaimg.cn/large/00746wNnly1g1hli7uvnoj30mn0boae2.jpg)

* 2.当一个类包含虚函数的时候，就意味着，这个类要被继承，所以，会为这个类增加一个虚指针，而这个指针一般也会放在对象内存布局的最前面，这个，调用方法的时候，就通过这个虚指针取取得函数地址。

![](http://ww1.sinaimg.cn/large/00746wNnly1g1hlseghzij30k90dpgob.jpg)

## 4.实现多态

- 可见，当一个函数是虚函数的时候，通过父类指针，可以调用到子类的方法，这，也就是多态。

![](http://ww1.sinaimg.cn/large/00746wNnly1g1hm2l8g3dj30t10la78q.jpg)

- 关于虚指针的问题

  虚指针只存在一个，子类继承父类的虚指针。虚表，每个类都有一张虚表，在编译的时候，由虚指针取决定指向哪里。

## 5.关于虚构造函数和虚析构函数

* 1.构造函数，不能是虚函数。

  ①从存储空间角度

      虚函数对应一个vtable，这大家都知道，可是这个vtable其实是存储在对象的内存空间的。问题出来了，如果构造函数是虚的，就需要通过 vtable来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。

  ②从使用角度

          虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。

  ```
  虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。
  ```

  ③构造函数不需要是虚函数，也不允许是虚函数

  ```
    因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。
  ```

  ④从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数  

  ```
    从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数
  ```

* 2.为什么析构函数要是虚函数

  看图说话：![](http://ww1.sinaimg.cn/large/00746wNnly1g1hmihn6waj30qn0hfada.jpg)

  当用父类的指针取删除子类的对象的时候，调用的却是父类的析构函数？可是，这是个子类的对象啊。万一，子类的数据中，有指针类型的数据怎么办，是不是会发生内存泄露。

  - 所以，虚析构函数就出来了。

    ![](http://ww1.sinaimg.cn/large/00746wNnly1g1hmpqvma9j30wu0ledmq.jpg)

    生成子类的对象，一定会调用到父类的构造函数。那么，既然调用了父类构造函数，自然也要调用父类析构函数，要不然，不也内存泄露了，合情合理。可是，怎么没有调用子类构造函数呢？

    ![](http://ww1.sinaimg.cn/large/00746wNnly1g1hmuue2dhj30th0jmjx1.jpg)

    .当把父类的析构函数写成虚函数的时候，就会调用到子类的析构函数了。

* 而且，可以发现，构造对象的时候，先调用父类的构造函数，然后，再调用子类的构造函数。

* 删除对象的时候，先调用子类的析构函数，再调用父类的析构函数。